/* subproto_request.h -- generated by Trunnel v1.5.3.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#ifndef TRUNNEL_SUBPROTO_REQUEST_H
#define TRUNNEL_SUBPROTO_REQUEST_H

#include <stdint.h>
#include "trunnel.h"

#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_SUBPROTO_REQUEST)
struct trn_subproto_request_st {
  uint8_t protocol_id;
  uint8_t proto_cap_number;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_subproto_request_st trn_subproto_request_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_TRN_SUBPROTO_REQUEST_EXT)
struct trn_subproto_request_ext_st {
  TRUNNEL_DYNARRAY_HEAD(, struct trn_subproto_request_st *) reqs;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct trn_subproto_request_ext_st trn_subproto_request_ext_t;
/** Return a newly allocated trn_subproto_request with all elements
 * set to zero.
 */
trn_subproto_request_t *trn_subproto_request_new(void);
/** Release all storage held by the trn_subproto_request in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void trn_subproto_request_free(trn_subproto_request_t *victim);
/** Try to parse a trn_subproto_request from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated trn_subproto_request_t. On failure, return -2 if the
 * input appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t trn_subproto_request_parse(trn_subproto_request_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_subproto_request in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t trn_subproto_request_encoded_len(const trn_subproto_request_t *obj);
/** Try to encode the trn_subproto_request from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_subproto_request_encode(uint8_t *output, size_t avail, const trn_subproto_request_t *input);
/** Check whether the internal state of the trn_subproto_request in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *trn_subproto_request_check(const trn_subproto_request_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_subproto_request_clear_errors(trn_subproto_request_t *obj);
/** Return the value of the protocol_id field of the
 * trn_subproto_request_t in 'inp'
 */
uint8_t trn_subproto_request_get_protocol_id(const trn_subproto_request_t *inp);
/** Set the value of the protocol_id field of the
 * trn_subproto_request_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int trn_subproto_request_set_protocol_id(trn_subproto_request_t *inp, uint8_t val);
/** Return the value of the proto_cap_number field of the
 * trn_subproto_request_t in 'inp'
 */
uint8_t trn_subproto_request_get_proto_cap_number(const trn_subproto_request_t *inp);
/** Set the value of the proto_cap_number field of the
 * trn_subproto_request_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int trn_subproto_request_set_proto_cap_number(trn_subproto_request_t *inp, uint8_t val);
/** Return a newly allocated trn_subproto_request_ext with all
 * elements set to zero.
 */
trn_subproto_request_ext_t *trn_subproto_request_ext_new(void);
/** Release all storage held by the trn_subproto_request_ext in
 * 'victim'. (Do nothing if 'victim' is NULL.)
 */
void trn_subproto_request_ext_free(trn_subproto_request_ext_t *victim);
/** Try to parse a trn_subproto_request_ext from the buffer in
 * 'input', using up to 'len_in' bytes from the input buffer. On
 * success, return the number of bytes consumed and set *output to the
 * newly allocated trn_subproto_request_ext_t. On failure, return -2
 * if the input appears truncated, and -1 if the input is otherwise
 * invalid.
 */
ssize_t trn_subproto_request_ext_parse(trn_subproto_request_ext_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * trn_subproto_request_ext in 'obj'. On failure, return a negative
 * value. Note that this value may be an overestimate, and can even be
 * an underestimate for certain unencodeable objects.
 */
ssize_t trn_subproto_request_ext_encoded_len(const trn_subproto_request_ext_t *obj);
/** Try to encode the trn_subproto_request_ext from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t trn_subproto_request_ext_encode(uint8_t *output, size_t avail, const trn_subproto_request_ext_t *input);
/** Check whether the internal state of the trn_subproto_request_ext
 * in 'obj' is consistent. Return NULL if it is, and a short message
 * if it is not.
 */
const char *trn_subproto_request_ext_check(const trn_subproto_request_ext_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int trn_subproto_request_ext_clear_errors(trn_subproto_request_ext_t *obj);
/** Return the length of the dynamic array holding the reqs field of
 * the trn_subproto_request_ext_t in 'inp'.
 */
size_t trn_subproto_request_ext_getlen_reqs(const trn_subproto_request_ext_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * reqs of the trn_subproto_request_ext_t in 'inp'.
 */
struct trn_subproto_request_st * trn_subproto_request_ext_get_reqs(trn_subproto_request_ext_t *inp, size_t idx);
/** As trn_subproto_request_ext_get_reqs, but take and return a const
 * pointer
 */
 const struct trn_subproto_request_st * trn_subproto_request_ext_getconst_reqs(const trn_subproto_request_ext_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * reqs of the trn_subproto_request_ext_t in 'inp', so that it will
 * hold the value 'elt'. Free the previous value, if any.
 */
int trn_subproto_request_ext_set_reqs(trn_subproto_request_ext_t *inp, size_t idx, struct trn_subproto_request_st * elt);
/** As trn_subproto_request_ext_set_reqs, but does not free the
 * previous value.
 */
int trn_subproto_request_ext_set0_reqs(trn_subproto_request_ext_t *inp, size_t idx, struct trn_subproto_request_st * elt);
/** Append a new element 'elt' to the dynamic array field reqs of the
 * trn_subproto_request_ext_t in 'inp'.
 */
int trn_subproto_request_ext_add_reqs(trn_subproto_request_ext_t *inp, struct trn_subproto_request_st * elt);
/** Return a pointer to the variable-length array field reqs of 'inp'.
 */
struct trn_subproto_request_st * * trn_subproto_request_ext_getarray_reqs(trn_subproto_request_ext_t *inp);
/** As trn_subproto_request_ext_get_reqs, but take and return a const
 * pointer
 */
const struct trn_subproto_request_st *  const  * trn_subproto_request_ext_getconstarray_reqs(const trn_subproto_request_ext_t *inp);
/** Change the length of the variable-length array field reqs of 'inp'
 * to 'newlen'.Fill extra elements with NULL; free removed elements.
 * Return 0 on success; return -1 and set the error code on 'inp' on
 * failure.
 */
int trn_subproto_request_ext_setlen_reqs(trn_subproto_request_ext_t *inp, size_t newlen);


#endif
